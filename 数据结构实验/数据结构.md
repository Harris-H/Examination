$P143$页面答案

**第一章 绪论**

数据结构是研究非数值计算的程序设计问题中计算机的**操作对象**以及他们之间**关系和运算**的科学。

![img](https://iknow-pic.cdn.bcebos.com/342ac65c10385343da7280229c13b07eca808877?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1)

![image-20201228092832186](C:\Users\HeHao\AppData\Roaming\Typora\typora-user-images\image-20201228092832186.png)

逻辑结构分为：线性，非线性。储存结构分为：顺序，链式。

与数据元素本身的形式、内容、相对位置、个数无关的数据的逻辑结构。

数据项是数据的最小单位，数据元素是数据的基本单位。

数据结构研究的内容不包括有穷性和健壮性。

当要写时间复杂度时，如果代码给出具体数字，则时间复杂度为: $O(1)$。

---

**随机存取和顺序存取**

![image-20201228095527450](C:\Users\HeHao\AppData\Roaming\Typora\typora-user-images\image-20201228095527450.png)

![img](file:///C:\Users\HeHao\Documents\Tencent Files\1479898695\Image\C2C\00C047F9EFA70E994CB6CA7C6BAE0BB0.png)

算法分析的内容：时间和空间复杂度。

算法分析的目的：分析算法的效率以求改进。

---

算法中语句执行的最大次数为算法的时间复杂度。

一个算法的执行时间等于其所有语句执行时间的量度。

任一语句的执行时间为该语句执行一次所需的时间与执行次数的乘积。

---

数据结构是一个二元组$(D,S)$，$D$是数据元素的有限集，$S$是$D$上关系的有限集。

语句的频度：语句的执行次数。

---

**第二章 线性表**

顺序表插入一个元素的期望：$\dfrac{n}{2}$。

顺序表删除一个元素的期望：$\dfrac{n-1}{2}$。

链表增加头结点的好处：  

1.对于插入和删除操作都是修改前驱结点的指针，若链表无头结点，则首元素没有前驱结点，插入和删除结点的操作会复杂。

2.使空表和非空表的处理统一，方便运算的实现。

设置尾指针的单循环链表：方便找到第一个节点和最后一个节点，便于在最后插入节点和删除第一个节点。

双循环链表：每个节点都有 两个指针域：前驱和后继。

带头结点的双循环链表：便于插入和删除尾节点。

带尾指针的单循环链表：删除表尾结点的时间复杂度：$O(n)$。

线性表在链式存储，查找或插入第$i$个元素的时间与$i$的数值成正比。

进行插入，删除第一个，最后一个元素的操作最好使用只有头指针的双循环链表。

**大题待会看**

---

**第三章 栈和队列**

有$n$个单元的顺序栈，若以地址高端为栈底，以$top$为栈顶指针，则当进栈时，$top$的变化为$top--$。

链式栈与顺序栈相比的明显优点是：通常不会出现栈满的情况。

循环队列的顺序表示：$front$指向队列头元素，$rear$指向队列尾元素的下一个位置，这是为了区分空栈和栈满。

循环队列的链式表示：头指针指向队头元素，尾指针指向队尾元素。

判断队列空的条件：头指针和尾指针都指向头结点。

链式表示的循环队列，删除最后一个元素：需要修改尾指针指向头结点。

栈是操作受限的线性表，其运算遵循后进先出的原则。

给定入栈序列$1,2,3\dots,n$，则出栈序列的个数为：$\dfrac{C(2n,n)}{n+1}$，$($卡特兰数$)$。

**大题待会看**

---

**第四章 串** 

---

**第五章 数组和广义表**

 稀疏矩阵：零元素个数远多于非零个数且分布没有规律的矩阵。

稀疏矩阵一般的压缩方法：三元组和十字链表。

广义表：0个或多个原字或子表组成的有限序列。

广义表的深度：最大包括的括号的对数。

三对角矩阵：

![image-20210101133927561](C:\Users\HeHao\AppData\Roaming\Typora\typora-user-images\image-20210101133927561.png)

放在一维数组储存下标从$0$开始，则$a_{(i,j)}=b[2i+j]$。

令$k=2i+j$。

则$i=\dfrac{k+1}{3},j=i+(k+1)\%3-1=\dfrac{k+1}{3}+(k+1)\%3-1$。

---

**第六章 树和二叉树**

二叉树的基本形态个数：

$1.$空二叉树。

2.只有一个根结点的二叉树。

3.右子树为空的二叉树。

4.左子树为空的二叉树。

5.左右子树都非空的二叉树。

---

$n$个结点的二叉树的形态个数：卡特兰数$\dfrac{C(2n,n)}{n+1}$。

树的结点数与度数关系：$d=n-1$。

度数为$0$的结点数$n_0$与度数为$2$的结点数$n_2$的关系：

$n_0=n_2+1$。

---

$n$层的满二叉树中结点的总数：$2^n-1$。

---

深度为$k$的二叉树叶子个数最多为：$2^{k-1}$。

 完全二叉树结点数为$n$，若$n$为奇数则$n_1=0$，否则$n_1=1$，且叶子结点数为：$\lceil\dfrac{n}{2}\rceil$。

---

当二叉树的高度等于结点数时，先序和后序序列相反。

三种遍历的叶子结点先后顺序相同。

二叉树的先序和中序遍历可能相同，当无左子树时满足。

后序线索树：当无左孩子时，左指针指向前驱，当无右孩子时，右指针指向后继，这里的前驱和后继是指后序序列中的前驱和后继。

先序线索二叉树不能求先序前驱，后序线索二叉树不能求后序后继。

---

<img src="C:\Users\HeHao\AppData\Roaming\Typora\typora-user-images\image-20201230163446459.png" alt="image-20201230163446459" style="zoom:50%;" />

---

 树转化为二叉树后是没有右子树的。

实现二叉树的后序遍历的非递归算法最佳方案是采用三叉链表。

---

<img src="C:\Users\HeHao\AppData\Roaming\Typora\typora-user-images\image-20201230164636219.png" alt="image-20201230164636219" style="zoom:50%;" />

![image-20201230164701664](C:\Users\HeHao\AppData\Roaming\Typora\typora-user-images\image-20201230164701664.png)

设森林$F$对应的二叉树为$B$。若$F$中有$n$个非终端结点，则$B$中右指针域为空的结点有$n+1$个。

---

$n$个权值的哈夫曼树的结点数为：$2n-1$。

每次合并减少一个结点。

---

树的度：树的结点度数的最大值。

二叉树是每个结点的度不超过2的有序树 (×)

当树为一条链时，有序树是无序的，而二叉树是有序的。

高为$n$的平衡二叉树至少有$f(n+2)-1$个结点。

$f(1)=f(2)=1,f(i)=f(i-1)+f(i-2)(i\ge 3),fibonacci$序列。

或者$F(n)=F(n-1)+F(n-2)+1,F(1)=1,F(2)=2,F(n)$表示高度为$n$的平衡二叉树最少需要的结点。

---

二叉树转化为树：某个结点如果有左孩子的所有右孩子连它。

![image-20210105190934933](C:\Users\HeHao\AppData\Roaming\Typora\typora-user-images\image-20210105190934933.png)

二叉树转换为森林：右孩子连线取消，然后二叉树转化为树。

填空，大题待补。

---

**第八章 查找** 

二分查找，等概率情况下查找成功的平均比较次数计算方法：

找到树的最大深度，然后一层一层的算。

![image-20210101150842107](C:\Users\HeHao\AppData\Roaming\Typora\typora-user-images\image-20210101150842107.png)

![image-20210101150946746](C:\Users\HeHao\AppData\Roaming\Typora\typora-user-images\image-20210101150946746.png)

对包含$n$个元素的散列表进行检索，平均检索长度是装填因子的函数，而不是$n$的函数。

线性探测法，所探测的这些位置的关键字不一定都是同义词。

散列的平均查找长度与处理冲突方法有关而与表长无关。

不存在特别好与坏的哈希函数，要看情况而定。

折半搜索与二叉排序树的时间性能有时不相同。

![image-20210101154346576](C:\Users\HeHao\AppData\Roaming\Typora\typora-user-images\image-20210101154346576.png)

分块查找的平均查找长度：

$\dfrac{1}{2}(\lceil\dfrac{n}{s}\rceil+s)+1$，$s$为$1$块的大小。

顺序查找适合于储存结构为顺序存储或者链接存储的线性表。

$B$树待补。

---

**第十章 排序**

快排的平均复杂度：$O(nlogn)$，最坏复杂度：$O(n^2)$。

快排在完全无序的情况下效果最好，时间复杂度为$O(nlogn)$,在有序情况下效果最差，时间复杂度为$O(n^2)$。

---

堆是一种选择排序。

从未排序序列中挑选元素，并依次放入已排序序列(初始为空)的一端的方法称为选择排序。

堆排序的最坏复杂度是$O(nlogn)$。

---

归并排序要求内存容量最大。

归并，冒泡是稳定的，堆排是不稳定的。

---

直接插入排序：最好情况下关键字比较次数：$n-1$，最坏情况下比较次数：$\dfrac{(n+2)(n-1)}{2}$，$2+3\dots+n$，有个哨兵在$a[0]$，所以从$2$开始加。

快排的平均时间复杂度比堆排块。

插入排序，归并排序，基数排序，冒泡排序是稳定的。

希尔排序，选择排序，快速排序，堆排序是不稳定的。

冒泡排序的最少比较次数为：$n-1$，即改进后的冒泡，如果第一次没有交换就说明已经排好了，退出，第一次比较$n-1$次。

---

